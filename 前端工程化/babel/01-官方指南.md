## 1. 指南

### 1.1 Babel 是什么？

#### Babel 是一个 JS 编译器

Babel 是一个工具链，主要用于将 ECMAScript 2015+版本的代码转换为向后兼容的 JS 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。

* 语法转换
* 通过 Polyfill 方式在目标环境中添加缺失的特性（通过 `@babel/polyfill` 模块）
* 源码转换(codemods)
* 。。。

#### 插件化

Babel 构建在插件之上。使用现有的或者自己编写的插件可以组成一个转换管道。



### 1.2 使用指南

Babel 工具链是由大量的工具组成的，无论你是“ 最终用户”还是继承 Babel，这些工具都简化了 Babel 的使用。

**更详细的用法见 `用法` 章节**

#### CLI命令行的基本用法

你所需要的所有的 Babel 模块都是作为独立的 npm 包发布的，并且（从版本7开始）都是以 `@babel` 作为冠名的。**这种模块化的设计能够让每种工具都针对特定使用情况进行设计。**

可以着中看一下 `@babel/core` 和 `@babel/cli`

* 核心库：`@babel/core` 模块中

  > 在 js 程序中直接 `require` 并使用它：
  >
  > ```javascript
  > const babel = require('@babel/core');
  > 
  > babel.transform("code", optionsObject);
  > ```

* CLI 命令行工具：`@babel/cli`

  > 是一个能够从终端（命令行）使用的工具。需要配合 `@babel/core` 模块使用
  >
  > ```shell
  > npm install --save-dev @babel/core @babel/cli
  > 
  > # 将 src 目录下的文件输出到 lib 目录下，也可通过 npx babel 执行
  > ./node_modules/.bin/babel src --out-dir lib
  > ```

#### 插件和预设（preset）

* 插件：**代码转换功能以插件的形式出现，插件是小型的 `JavaScript` 程序，用于指导 Babel 如何对代码进行转换。甚至也可以编写自己的插件将你所需要的任何代码转换功能应用到你的代码上。**

  > ```shell
  > # 将 ES2015+ 箭头函数语法转换为 ES5 语法
  > npm install -D @babel/plugin-transform-arrow-functions
  > ```
  >
  > ```javascript
  > const fn = () => 1;
  > 
  > // 转换后
  > var fn = function fn() {
  >     return 1;
  > }
  > ```
  >
  > **这样一个个添加插件用于转换比较麻烦，所以可以使用 `preset` **

* 预设(preset)：**将所需要的插件组合创建一个自己的 preset 并将其分享出去。**

  > ```shell
  > npm install --save-dev @babel/preset-env
  > 
  > ./node_modules/.bin/babel src --out-dir lib --presets=@babel/env
  > ```

#### Polyfill

**需要 Polyfill 加载来使用诸如 Promise 和 WeakMap 之类的新的内置组件、 `Array.from` 或 `Object.assign` 之类的静态方法、 `Array.prototype.includes` 之类的实例方法以及生成器函数（generator functions）（前提是你使用了 regenerator 插件）。为了添加这些功能，polyfill 将添加到全局范围（global scope）和类似 `String` 这样的原生原型（native prototypes）中。**

  * 直接全局范围内导入：有些功能不会被使用，这样的话有些 Polyfill 会造成资源浪费

    > ```javascript
    > // @babel/polyfill 模块包含 core-js 和一个自定义的 regenerator runtime 来模拟完整的 ES2015+ 环境。
    > import '@babel/polyfill';
    > 
    > // 从 Babel 7.4.0 开始，建议直接使用 core-js/stable （用于模拟 ECMAScript 的功能）和 regenerator-runtime/runtime （需要使用转译后的生成器函数）
    > import "core-js/stable";
    > import "regenerator-runtime/runtime";
    > ```

  * 使用 env preset 提供的 useBuiltIns 参数，这样就只会包含所需要的 Polyfill

    > ```json
    > {
    >   "presets": [
    >     [
    >       "@babel/env",
    >       {
    >         "targets": {
    >           "edge": "17",
    >           "firefox": "60",
    >           "chrome": "67",
    >           "safari": "11.1",
    >         },
    >         "useBuiltIns": "usage",
    >       }
    >     ]
    >   ]
    > }
    > ```
    >
    > ```javascript
    > // 示例代码
    > Promise.resolve().finally();
    > 
    > // 转化为（Edge 17 没有 Promise.prototype.finally）：
    > require("core-js/modules/es.promise.finally");
    > 
    > Promise.resolve().finally();
    > ```

#### 配置

可以通过多种方式来使用配置文件

#### 总结

**Babel 使用 @babel/cli 从终端运行 Babel, 利用 `@babel/polyfill` 来模拟所有新的 JavaScript 功能，而 env preset 只对我们所使用的并且目标浏览器中缺失的功能进行代码转换和加载 polyfill。**



### 1.3 配置 Babel

#### 配置文件类型

* babel.config.json

  ```json
  {
    "presets": [...],
    "plugins": [...]
  }
  ```

* .babelrc.json

  ```json
  {
    "presets": [...],
    "plugins": [...]
  }
  ```

* package.json：选择将 [`.babelrc.json`](https://www.babeljs.cn/docs/configuration#babelrcjson) 中的配置信息作为 `babel` 键（key）的值添加到 `package.json` 文件中

  ```json
  {
    "name": "my-package",
    "version": "1.0.0",
    "babel": {
      "presets": [ ... ],
      "plugins": [ ... ],
    }
  }
  ```

* 用 js 编写配置文件：可以用 js 编写 babel.config.json 和 .babelrc.json 文件

  ```javascript
  // 可以调用 Node.js 的任何 API，例如基于进程环境进行动态配置
  const presets = [ ... ];
  const plugins = [ ... ];
  
  if (process.env["ENV"] === "prod") {
    plugins.push(...);
  }
  
  module.exports = { presets, plugins };
  ```

#### 使用 CLI

```shell
babel --plugins @babel/plugin-transform-arrow-functions script.js
```

#### 使用 API

```js
require("@babel/core").transform("code", {
  plugins: ["@babel/plugin-transform-arrow-functions"]
});
```

#### 文件优先级

```tex
babel.config.json < .babelrc < programmatic options from @babel/cli
```

#### 合并配置项

```js
const config = {
  plugins: [["plugin-1a", { loose: true }], "plugin-1b"],
  presets: ["preset-1a"],
  sourceType: "script"
}

const newConfigItem = {
  plugins: [["plugin-1a", { loose: false }], "plugin-2b"],
  presets: ["preset-1a", "preset-2a"],
  sourceType: "module"
}

BabelConfigMerge(config, newConfigItem);
// returns
({
  plugins: [
    ["plugin-1a", { loose: false }],
    "plugin-1b",
    ["plugin-1a", { loose: false }],
    "plugin-2b"
  ], // new plugins are pushed
  presets: [
    "preset-1a",
    "preset-1a",
    "preset-2b"
  ], // new presets are pushed
  sourceType: "module" // sourceType: "script" is overwritten
})
```



## 2. 概览

### 2.1 插件

**Babel 是一个编译器（输入源码 => 输出编译后的代码）。就像其他编译器一样，编译过程分为三个阶段：解析、转换和打印输出。**

  #### 转换插件

转换插件用于转化代码

> 转换插件将启用相应的语法插件，因此不必同时指定这两种插件

#### 语法插件

这些插件只允许 Babel **解析（parse）** 特定类型的语法（而不是转换）。

> 注意：转换插件会自动启用语法插件。因此，如果你已经使用了相应的转换插件，则不需要指定语法插件。

或者，你也可以通过 Babel 解析器传递任何 [`plugins` 参数](https://www.babeljs.cn/docs/babel-parser#plugins) ：

Your `.babelrc`:

```json
{
  "parserOpts": {
    "plugins": ["jsx", "flow"]
  }
}
```

#### 插件的路径和名称

```javascript
{
  // 在 node_module 中查找
  "plugins": ["babel-plugin-myPlugin"]
  // 可以指定 相对/绝对路径。
  "plugins": ["./node_modules/asdf/plugin"],
  // 插件名称的前缀为 babel-plugin-，如下使用
  "plugins": [
    "myPlugin",
    "babel-plugin-myPlugin" // 两个插件实际是同一个
  ],
  // 带有作用域（scope）的插件
  "plugins": [
    "@org/babel-plugin-name",
    "@org/name" // 两个插件实际是同一个
  ]
}
```

#### 插件顺序

**如果两个转化插件都将处理“程序”的某个代码片段，此时插件的排列顺序很重要。**

* **插件在 Presets 前运行；**
* **插件顺序为：从前往后；**
* **Preset 顺序为：从后往前；**

#### 插件参数

参数由插件名和参数对象组成一个数组，可以在配置文件中设置

```javascript
"plugins": ["pluginA", ["pluginB"], [
    "pluginC",
    {, // 以数组的第二项对象传递参数
    	key: value
    }
]]
```

#### 插件开发

参考 [babel-handbook](https://github.com/thejameskyle/babel-handbook)