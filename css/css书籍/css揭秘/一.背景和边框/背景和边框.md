1. 半透明边框

```css
div {
    width: 100px;
    height: 100px;
    margin-top: 50px;
    background: white;
}
.box2 {
    border: 10px solid rgba(250, 250, 250, .5);
    background-clip: padding-box;
}
```

效果图: 

![image-20200308151320626](..\image\半透明边框.jpg)



## 2. 多重边框

```css
	/* 方案1：box-shadow 方案 */
    .box {
      margin: 50px;
      width: 100px;
      height: 100px;
      background: yellowgreen;
      /* box-shadow形成的投影是一层层叠加的, 第一层位于最顶层, 依次类推 */
      /* 注意点: 
       * 1. 投影的行为跟边框不完全一致，因为它不会影响布局，而且也不会
            受到box-sizing 属性的影响。不过，你还是可以通过内边距或外边
            距（这取决于投影是内嵌和还是外扩的）来额外模拟出边框所需要
            占据的空间。
         2. 上述方法所创建出的假“边框”出现在元素的外圈。它们并不会响
            应鼠标事件，比如悬停或点击。如果这一点非常重要，你可以给
            box-shadow 属性加上inset 关键字，来使投影绘制在元素的内圈。
            请注意，此时你需要增加额外的内边距来腾出足够的空隙。
       */
      box-shadow: 0 0 0 10px #655,
        0 0 0 15px deeppink,
        0 2px 5px 15px rgba(0, 0, 0, .6);
    }

    /* 方案2：outline 方案 */
    /* 优点：
     * 1. 边框样式可以多样化(实线，虚线...)
     * 2. 可以通过outline-offset 属性来控制它跟
          元素边缘之间的间距，这个属性甚至可以接受负值。这对于某些效果来说非
          常有用。
    */
    .box2 {
      margin: 50px;
      width: 100px;
      height: 100px;
      background: #6c5a57;
      /* 注意点:
       * 1. 只适用于双层“边框”的场景，因为 outline 并不能
            接受用逗号分隔的多个值。如果我们需要获得更多层的边框，前一
            种方案就是我们唯一的选择了。
         2. 边框不一定会贴合border-radius属性产生的圆角，因此如果元素
            是圆角的，它的描边可能还是直角的（参见图2-9）。请注意，这种行
            为被CSS 工作组认为是一个bug，因此未来可能会改为贴合borderradius
            圆角。
         3. 根据 CSS 基本 UI 特性（第三版）规范（http://w3.org/TR/css3-ui）所
            述，“描边可以不是矩形”。尽管在绝大多数情况下，描边都是矩形
            的，但如果你想使用这个方法，请切记：最好在不同浏览器中完整
            地测试最终效果。
       */
      outline: 1px dotted deeppink;
      outline-offset: -5px;
    }
```

效果图: 

![image-20200308155458375](..\image\多重边框.png)



## 3. 灵活的背景定位

```css
	/* background-position 扩展语法方案 */
    .box {
      margin: 50px;
      width: 200px;
      height: 200px;
      /* 回退方案, 如果不支持扩展语法的话, 就可运用默认的位置 */
      background: url(../image/image1.jpg) no-repeat bottom right #58a;
      /* 允许我们指定背景图片距离任
         意角的偏移量，只要我们在偏移量前面指定关键字。举例来说，如果想让背
         景图片跟右边缘保持20px 的偏移量，同时跟底边保持10px 的偏移量， 
      */
      background-position: right 20px bottom 10px;
    }

    /* background-origin 方案: 可以运用于偏移量与容器的内边距一致。 */
    .box1 {
      margin: 50px;
      width: 200px;
      height: 200px;
      padding: 10px;
      background: url(../image/image1.jpg) no-repeat bottom right #58a;
      background-origin: content-box;
    }

    /* calc() 方案 */
    .box3 {
      margin: 50px;
      width: 200px;
      height: 200px;
      background: url(../image/image1.jpg) no-repeat #58a;
      background-position: calc(100% - 20px) calc(100% - 10px);
    }
```

效果图:

![image-20200308155350356](..\image\灵活的背景定位.png)



## 4. 边框内圆角

```css
	.box {
      /* 
        同时运用 outline 和 box-shadow 原因: 
        1. outline 不会跟着元素的圆角走（因而显示出直角），但 box-shadow 会
        2. box-shadow 会刚好填补描边和容器圆角之间的空隙
       */
      outline: .6em solid #655;
      box-shadow: 0 0 0 .4em #655;
      /* todo calculate max of this */

      max-width: 10em;
      border-radius: .8em;
      padding: 1em;
      margin: 1em;
      background: tan;
      font: 100%/1.5 sans-serif;
    }
```

效果图: 

![image-20200308152222293](..\image\边框内圆角.png)

## 5. 条纹背景

```css
	div {
      margin: 30px 100px;
      width: 200px;
      height: 200px;
    }

    /* 水平条纹 */
    .level {
      /* 
       * 如果多个色标具有相同的位置，它们会产生一个无限小的过渡区域，
       * 过渡的起止色分别是第一个和最后一个指定值。从效果上看，颜色会在那
       * 个位置突然变化，而不是一个平滑的渐变过程。” 
       */
      /* background: linear-gradient(#fb3 50%, #58a 50%); */

      /* 
       * 如果某个色标的位置值比整个列表中在它之前的色标的位置值都要小，则该色标的位置值会被设置为它前面所有色标位置值的最大值
       * 这意味着，如果我们把第二个色标的位置值设置为0，那它的位置就总是会被浏览器调整为前一个色标的位置值
       */
      /* background: linear-gradient(#fb3 30%, #58a 0); */

      /* 
       * 生成三种颜色的水平条纹
       */
      background: linear-gradient(#fb3 33.3%,
          #58a 0, #58a 66.6%, yellowgreen 0);
      /* 
       * 渐变是一种由代码生成的图像，我们能像对待其他任何背景图像那
       * 样对待它，而且还可以通过background-size 来调整其尺寸
       */
      background-size: 100% 20%;
    }

    /* 垂直条纹 */
    .vertical {
      /* 需要在开头加上一个额外的参数来指定渐变的方向 */
      background: linear-gradient(to right,
          /* 或 90deg */
          #fb3 50%, #58a 0);
      background-size: 30px 100%;
    }

	/* 斜向条纹 */
    .direction {
      background: repeating-linear-gradient(60deg,
          #fb3, #fb3 15px, #58a 0, #58a 30px);
    }

    /* 同色系条纹 */
    .same {
      background: repeating-linear-gradient(30deg,
          #79b, #79b 15px, #58a 0, #58a 30px);
    }
```

效果图:

![image-20200308155152780](..\image\条纹背景.png)





















