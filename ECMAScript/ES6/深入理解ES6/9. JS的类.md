## ES5 中的仿类结构

在 ES5 中与类最接近的是: 创建一个构造器, 然后将方法指派到该构造器的原型上, 这种方式通常被称为创建一个自定义类型

```javascript
function PersonType(name) {
	this.name = name;
}

PersonType.prototype.sayName = function() {
	console.log(this.name);
};

let person = new PersonType("Nicholas");
person.sayName(); // 输出 "Nicholas"

console.log(person instanceof PersonType); // true
console.log(person instanceof Object); // true
```



## 类的声明

类在  ES6 中最简单的形式就是类声明, 看起来"很像"其他语言中的类



### 1. 基本的类声明

以 `class` 关键字开始, 其后是类的名称; 剩余部分的语法看起来就像对象字面量中的方法简写, 在方法之间不需要使用逗号.

```javascript
class PersonClass {
    // 等价于 PersonType 构造器
    constructor(name) {
        this.name = name;
    }
    
    // 等价于 PersonType.prototype.sayName
    sayName() {
        console.log(this.name)
    }
}

let person = new PersonClass('Nicholas');
person.sayName(); // 输出 "Nicholas"

console.log(person instanceof PersonClass); // true
console.log(person instanceof Object); // true
// class 类也属于函数
console.log(typeof PersonClass); // "function"
console.log(typeof PersonClass.prototype.sayName); // "function"
```



### 2. 与自定义类型的区别

尽管类与自定义类型之间有相似性, 但仍然有一些重要的区别: 

1. 类声明不会被提升,  这与函数定义不同. 类声明的行为与 `let` 相似, 因此在程序的执行到达声明处之前, 类会存在与暂时性死区内.
2. 类声明中的所有代码会自动运行在严格模式下, 并且也无法退出严格模式
3. 类的所有方法都是不可枚举的, 这是对与自定义类型的显著变化, 后者必须用 `Object.defineProperty()` 才能将方法改变为不可枚举的.
4. 类的所有方法内部都没有 `[[Construct]]`, 因此使用 `new` 来调用它们会抛出错误.
5. 调用类构造器时不使用 `new` , 会抛出错误
6. 试图在类的方法内部重写类名, 会抛出错误

上例中 `PersonClass` 类声明实际上就直接的等价于以下未使用类语法的代码: 

```javascript
// 直接等价与 PersonClass
let PersonType2 = (function() {
   "use strict";
    
    // 这里确保了第 6 点: 不能在类的内部重写类名
    const PersonType2 = function(name) {
        // 确认函数被调用时使用了 new
        if (typeof new.target === 'undefind') {
            throw new Error("Constructor must be called with new.");
        }
        
        this.name = name;
    }
    
    Object.defineProperty(PersonType2.prototype, "sayName" {
    	value: function() {
        	// 确认函数被调用时没有使用 new
        	if (typeof new.target === 'undefind') {
                throw new Error("Method cannot be called with new.")
            }
        	
        	console.log(this.name);
    	},
        enumerable: false,
        writable: true,
        configurable: true
    });
	
	return PersonType2;
}())
```

> **只有在类的内部, 类名才被视为是使用 `const` 声明的. 也就意味着可以在外部重写类名, 但不能在类的方法内部这么做**
>
> ```javascript
> class Foo {
> 	constructor() {
> 		Foo = "bar"; // 执行时抛出错误
> 	}
> }
> 
> // 但在类声明之后没问题
> Foo = "baz";
> ```



## 类表达式

**类与函数有相似之处, 即它们都有两种形式: 声明与表达式. 类表达式被设计用于变量声明, 或可作为参数传递给函数**



### 1. 基本的类表达式

```javascript
let PersonClass = class {
	// 等价于 PersonType 构造器
	constructor(name) {
		this.name = name;
	}
    
	// 等价于 PersonType.prototype.sayName
	sayName() {
		console.log(this.name);
	}
};

let person = new PersonClass("Nicholas");
person.sayName(); // 输出 "Nicholas"

console.log(person instanceof PersonClass); // true
console.log(person instanceof Object); // true
console.log(typeof PersonClass); // "function"
console.log(typeof PersonClass.prototype.sayName); // "function"
```

除了语法差异, 类表达式的功能等价于类声明. **相对于函数声明与函数表达式之间的区别, 类声明与类表达式都不会被提升, 因此对代码运行时的行为影响甚微**



### 2. 具名类表达式

上面的示例中使用的是一个匿名的类表达式, 不过就像函数表达式那样, 也可以为类表达式命名. 为此需要在 `class` 关键字后添加标识符

```javascript
let PersonClass = class PersonClass2 {
    // 等价于 PersonType 构造器
	constructor(name) {
		this.name = name;
	}
    
	// 等价于 PersonType.prototype.sayName
	sayName() {
		console.log(this.name);
	}
}

console.log(typeof PersonClass); // "function"
console.log(typeof PersonClass2); // "undefined"
```

类标识符 `PersonClass2` 只在类定义内部中存在, 只能用在类方法内部



## 作为一级公民的类

在编程中, 能被作为值值来使用的就成为一级公民(**first-class citizen**), 意味着它能作为参数传给函数、能作为函数返回值、能用来给变量赋值。 JS的函数就是一级公民

**类同样也是一级公民**

1. 作为参数传入函数:

   ```javascript
   function createObject(classDef) {
   	sreturn new classDef();
   }
   let obj = createObject(class {
   	sayHi() {
   		console.log("Hi!");
   	}
   });
   obj.sayHi(); // "Hi!"
   ```

2. 类表达式的另一个有趣用途是立即调用类构造器, 以创建单例

   ```javascript
   let person = new class {
       construstor(name) {
           this.name = name;
       }
       
       sayName() {
           console.log(this.name);
       }
   }("Nicholas");
   
   person.sayName(); // "Nicholas"
   ```



## 访问器属性

创建一个 `getter`, 使用 `get` 关键字, 并要与后方标识符之间留出空格;

创建一个 `setter`, 使用 `set` 关键字, 并要与后方标识符之间留出空格;

```javascript
class CustomHTMLElement {
	constructor(element) {
		this.element = element;
	}
	get html() {
		return this.element.innerHTML;
	}
	set html(value) {
		this.element.innerHTML = value;
	}
}

var descriptor = Object.getOwnPropertyDescriptor(CustomHTMLElement.prototype, "html");

console.log("get" in descriptor); // true
console.log("set" in descriptor); // true
console.log(descriptor.enumerable); // false
```



## 需计算的成员名

对象字面量与类之间的相似点还不仅前面那些. 类方法与类访问器属性也都能使用需计算的名称. **语法相同于对象字面量中的需计算名称: 无须使用标识符, 而是用方括号来包裹一个表达式**

```javascript
let methodName = "sayName",
    propertyName = "html";

class PersonClass {
    constructor(name) {
        this.name = name;
    }
    
    [methodNmae]() {
        console.log(this.name);
    }
    
    set [propertyName](value) {
        this.name = value;
    }
    
    get [propertyName]() {
        return this.name;
    }
}

let me = new PersonClass("Nicholas");
me.sayName(); // "Nicholas"
```



## 生成器方法

在类上同样可以定义一个生成器

```javascript
class MyClass {
	*createIterator() {
		yield 1;
        yield 2;
		yield 3;
	}
}

let instance = new MyClass();
let iterator = instance.createIterator();
```

**也可以自定义一个默认迭代器, 让实例成为可迭代对象 **

```javascript
class Collection {
	constructor() {
		this.items = [];
	}
	*[Symbol.iterator]() {
		yield *this.items.values();
	}
}

var collection = new Collection();
collection.items.push(1);
collection.items.push(2);
collection.items.push(3);

for (let x of collection) {
	console.log(x);
}

// 输出：
// 1
// 2
// 3
```



## 静态成员

静态成员表示为定义在类上面的方法(类 相当于 函数, 也可以当作对象一样添加属性和方法) ==> **静态成员不能用实例来访问, 始终需要直接用类自身来访问它们**

**类定义静态成员, 只要在方法与访问器属性的名称前添加正式的 `static` 标注**

**注意: 可以在类中的任何方法与访问器属性上使用 `static` 关键字, 唯一限制就是不能将它用于 `constructor` 方法的定义**

```javascript
class PersonClass {
	// 等价于 PersonType 构造器
    constructor(name) {
		this.name = name;
	}
    
	// 等价于 PersonType.prototype.sayName
	sayName() {
		console.log(this.name);
	}
    
    // 等价于 PersonType.create
    static create(name) {
		return new PersonClass(name);
	}
}

let person = PersonClass.create("Nicholas");
```

