## ES6中的参数默认值

1. 提供了为参数提供默认值的语法,  当未传递参数或明确将参数值指定为 `undefined` 时, 参数默认值就会生效

   ```javascript
     function makeRequest(url, timeout = 2000, callback = ()  => {}) {
     	// 函数的剩余部分
     }
   ```

   

2. arguments 对象表现

   在 ES5 中, 非严格模式下, `arguments`  对象会反映出具名参数的变化 

   ```javascript
   function mixArgs(first, second) {
     	console.log(first === arguments[0]);// true
     	console.log(second === arguments[1]); // true
     	first = "c";
     	second = "d";
     	console.log(first === arguments[0]); // true
     	console.log(second === arguments[1]); // true
     }
     mixArgs("a", "b");
   ```

     在严格模式下, `arguments` 对象不再反映出具名参数的变化

   ```javascript
   function mixArgs(first, second) {
     	"use strict";
     	console.log(first === arguments[0]); // true
     	console.log(second === arguments[1]); // true
     	first = "c";
     	second = "d"
     	console.log(first === arguments[0]); // false
     	console.log(second === arguments[1]); // false
     }
     mixArgs("a", "b");
   ```

  	在使用 ES6 参数默认值的函数中, `arguments` 对象的表现总是与 ES5 的严格模式一致, 无	论此时函数是否明确运行在严格模式下

3. **默认值表达式**

   参数默认值最有一个意思的特性或许就是默认值并不要求一定是基本类型的值, 可以是一个合法的表达式

   ```javascript
   // 1. 调用函数, 需要注意的是, 函数是惰性加载的, 只有在没有提供参数或参数为 undefined 才会调用
   function add(first, second = getValue()) {
   	return first + second;
   }
   
   // 2. 可以将前面的参数作为 后面参数的默认值
   function add(first, second = first) {
   	return first + second;
   }
   
   // 3. 引用其他参数案例为参数进行默认赋值时, 仅允许引用前方的参数, 否则的话, 会触发 TDZ(暂时性时区) 错误
   function add(first = second, second) {
   	return first + second;
   }
   console.log(add(1, 1)); // 2
   console.log(add(undefined, 1)); // 抛出错误
   ```

4. 参数默认值的暂时性死区

   **与 `let` 声明相似, 函数每个参数都会创建一个新的标识符绑定, 它在初始化之前不允许被访问, 否则会抛出错误**

   ```javascript
   function add(first = second, second) {
   	return first + second;
   }
   console.log(add(1, 1)); // 2
   console.log(add(undefined, 1)); // 抛出错误
   
   // ===== 上面 例子 对应着下面的后台代码, 就会知道为什么会如何
   // JS 调用 add(1, 1) 可表示为
   let first = 1;
   let second = 1;
   // JS 调用 add(1) 可表示为  === 触发 TDZ 
   let first = second;
   let second = 1;
   ```

   **函数参数拥有各自的作用域和暂时性死区, 与函数体的作用域相分离, 这意味着参数的默认值不允许访问在函数体内部声明的任意变量**



## 使用不具名参数

**在 JS 中, 函数并不强求参数的数量要等于已定义具名参数的数量, 也就是说, 传递的参数允许少于或多于正式指定的参数(形参)**。参数的默认值让函数在接受更少参数时的 行为更清晰， 而不具名试图让相反情况的问题也更好地解决

1. 在 ES5 中，常使用 `arguments` 用于查看传递给函数的所有参数

2. 在 ES6 中，引入了 剩余参数，由三个点(...)与一个紧跟着的具名参数指定， 它会是包含传递给函数的其余参数的一个数组。

   ```javascript
   function pick(object, ...keys) {
       // keys 包含着所有除了 object 参数之外的剩余参数
   }
   ```

3. 函数的 `length` 属性用于指示具名参数的 数量, 而剩余参数对其毫无影响.

   ```javascript
   function pick(object, ...keys) {
       // pick.length === 1 因为只有 object 参数被用于计算该值
   }
   ```

4. 剩余参数 的限制条件: 

   1. 函数只能有一个剩余参数, 并且它必须被放在最后

      ```javascript
      // 语法错误：不能在剩余参数后使用具名参数
      function pick(object, ...keys, last) {
      ```

   2. 不能用在对象字面量的 setter(属性描述符中的一种set) 属性中

      ```javascript
      // 存在此限制的原因是：对象字面量的 setter 被限定只能使用单个参数；而剩余参数按照定义是不限制参数数量的，因此它在此处不被许可。
      let object = {
      	// 语法错误：不能在 setter 中使用剩余参数
      	set name(...value) {
      		// 一些操作
      	}
      };
      ```

      