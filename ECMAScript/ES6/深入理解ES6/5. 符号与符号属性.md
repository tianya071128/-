## 创建符号值

* 符号没有字面量形式, 这在 `JS` 的基本类型中是独一无二的. 使用全局 `Symbol` 函数来创建一个符号值
* 由于符号值是基本类型的值, 因此调用 `new Symbol()` 将会抛出错误. 你可以通过 new
  Object(yourSymbol) 来创建一个符号实例，但尚不清楚这能有什么作用。
* `Symbol` 函数还可以接受一个额外的参数用于描述符号值, 该描述不能用来访问对应属性, 但它能用于调试. **符号的描述信息被存储在内部属性 `[[Description]]` 中, 当符号的 `toString()` 方法被显式或隐式调用时, 该属性都会被读取. 此外没有任何办法可以从代码中直接访问 `[[Description]]` 属性**

```javascript
let firstName = Symbol("first name");
let person = {};

person[firstName] = "Nicholas";

console.log("first name" in person); // false
console.log(person[firstName]); // "Nicholas"
console.log(firstName); // "Symbol(first name)"
```

* 识别符号值: 可以使用 `typeof` 运算符来判断一个变量是否为符号

  ```javascript
  let symbol = Symbol("test symbol");
  
  console.log(typeof symbol); // "symbol"
  ```

  尽管有其他方法可以判断一个变量是否为符号， typeof 运算符依然是最准确、最优先
  的判别手段。



## 使用符号值

可以在任意能使用 "需计算属性名" 的场合使用符号. 还可以在 `Object.defineProperty()` 或 `Object.defineProperties()` 调用中使用它

```javascript
let firstName = Symbol("first name");

// 使用一个需计算字面量属性
let person = {
	[firstName]: "Nicholas"
};

// 让该属性变为只读
Object.defineProperty(person, firstName, { writable: false });

let lastName = Symbol("last name");

Object.defineProperties(person, {
	[lastName]: {
		value: "Zakas",
		writable: false
	}
});

console.log(person[firstName]); // "Nicholas"
console.log(person[lastName]); // "Zakas"
```



## 共享符号值

* 创建共享符号值, 应使用 `Symbol.for()` 方法而不是 `Symbol()` 方法. `Symbol.for()`方法仅接受单个字符串类型的参数，作为目标符号值的标识符，同时此参数也会成为该符号的描述信息。

  ```javascript
  let uid = Symbol.for("uid");
  let object = {};
  
  object[uid] = "12345";
  
  console.log(object[uid]); // "12345"
  console.log(uid); // "Symbol(uid)"
  ```

* `Symbol.for()` 方法首先会搜索全局符号注册表，看是否存在一个键值为 "uid" 的符号值。若是，该方法会返回这个已存在的符号值；否则，会创建一个新的符号值，并使用该键值将其记录到全局符号注册表中，然后返回这个新的符号值

* 

  ```javascript
  let uid = Symbol.for("uid");
  let object = {
  	[uid]: "12345"
  };
  
  console.log(object[uid]); // "12345"
  console.log(uid); // "Symbol(uid)"
  
  let uid2 = Symbol.for("uid");
  
  console.log(uid === uid2); // true
  console.log(object[uid2]); // "12345"
  console.log(uid2); // "Symbol(uid)"
  ```

* 可以使用 `Symbol.keyFor()` 方法在全局符号注册表中根据符号值检索出对应的键值,

  **注意: 使用 `Symobol()` 方法创建的是不会注册到全局符号注册表的**

  ```javascript
  let uid = Symbol.for("uid");
  console.log(Symbol.keyFor(uid)); // "uid"
  
  let uid2 = Symbol.for("uid");
  console.log(Symbol.keyFor(uid2)); // "uid"
  
  let uid3 = Symbol("uid");
  console.log(Symbol.keyFor(uid3)); // undefined
  ```

* 全局符号注册表类似于全局作用域，是一个共享环境，这意味着你不应当假设某些值是否已存在于其中。在使用第三方组件时，为符号的键值使用命名空间能够减少命名冲突的可能性，举个例子： jQuery 代码应当为它的所有键值使用 "jquery." 的前缀，如"jquery.element" 或类似的形式。



## 符号值的转换

* 符号类型在进行转换时非常不灵活, 因为其他类型缺乏与符号值的合理等价, 尤其是符号值无法被转换为字符串值或数值(会抛出错误)
* 无论对符号使用哪种数学运算符都会导致错误，但使用逻辑运算符则不会，因为符号值在逻辑运算中会被认为等价于 true （就像 JS中其他的非空值那样）。



## 检索符号属性

ES6 新增了Object.getOwnPropertySymbols() 方法，以便让你可以检索对象的符号类型属性。

```javascript
let uid = Symbol.for("uid");
let object = {
	[uid]: "12345"
};

let symbols = Object.getOwnPropertySymbols(object);

console.log(symbols.length); // 1
console.log(symbols[0]); // "Symbol(uid)"
console.log(object[symbols[0]]); // "12345"
```



## 使用知名符号暴露内部方法

**ES5 的中心主题之一是披露并定义了一些魔术般的成分，而这些部分是当时开发者所无法自行模拟的。 ES6 延续了这些工作，对原先属于语言内部逻辑的部分进行了进一步的暴露，允许使用符号类型的原型属性来定义某些对象的基础行为。**

**这些符号是: **

1. Symbol.hasInstance ：供 `instanceof` 运算符使用的一个方法，用于判断对象继承关系。
2. Symbol.isConcatSpreadable ：一个布尔类型值，在集合对象作为参数传递给Array.prototype.concat() 方法时，指示是否要将该集合的元素扁平化。
3. Symbol.iterator ：返回迭代器（参阅第七章）的一个方法。
4. Symbol.match ：供 String.prototype.match() 函数使用的一个方法，用于比较字符串。
5. Symbol.replace ：供 String.prototype.replace() 函数使用的一个方法，用于替换子字符串。
6. Symbol.search ：供 String.prototype.search() 函数使用的一个方法，用于定位子字符串
7. Symbol.species ：用于产生派生对象（参阅第八章）的构造器。
8. Symbol.split ：供 String.prototype.split() 函数使用的一个方法，用于分割字符串。
9. Symbol.toPrimitive ：返回对象所对应的基本类型值的一个方法。
10. Symbol.toStringTag ：供 String.prototype.toString() 函数使用的一个方法，用于创建对象的描述信息。
11. Symbol.unscopables ：一个对象，该对象的属性指示了哪些属性名不允许被包含在with 语句中。

> 重写知名符号所定义的方法, 会把一个普通对象改变成奇异对象, 因为它改变了一些默认的内部行为