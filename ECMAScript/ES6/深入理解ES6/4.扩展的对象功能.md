## 对象类别

对象类别包括: 

1. 普通对象: 拥有 JS 对象所有默认的内部行为
2. 奇异对象: 其内部行为在某些方面有别于默认行为
3. 标准对象: 在 ES6中被定义的对象, 例如 `Array` 、`Date` 等等. 标准对象可以是普通的, 也可以是奇异的
4. 内置对象: 在脚本开始运行时由 JS 运行环境提供的对象. 所有的标准对象都是内置对象



## 对象字面量语法的扩展

1. 当对象字面量中的属性只有名称时, JS 引擎会在周边作用域查找同名变量

   ```javascript
   function createPerson(name, age) {
   	return {
   		name,
   		age
   	};
   }
   ```

2. 方法简写: 可以省略冒号与 function 关键字

   > 同 ES5 方法的区别: 方法简写能使用 `super`, 而非简写的方法则不能使用.

   ```javascript
   var person = {
   	name: "Nicholas",
       // 这个也是标准函数, 不是箭头函数
   	sayName() {
   		console.log(this.name);
   	}
   };
   ```

3. 需计算属性名

   > * 在 ES5 中, 方括号允许你将变量或字符串字面量指定为属性名，而在字符串中允许存在作为标识符时会导致语法错误的特殊字符。
   >
   >   缺陷: 不能在对象属性中使用变量, 或者通过计算才能获得属性的
   >
   >   ```javascript
   >   var person = {},
   >   	lastName = "last name";
   >   
   >   person["first name"] = "Nicholas";
   >   person[lastName] = "Zakas";
   >   
   >   console.log(person["first name"]); // "Nicholas"
   >   console.log(person[lastName]); // "Zakas"
   >   
   >   // === ES5 中不允许的 ===
   >   var person = {
   >       [lastName]:'Zakas'
   >   }
   >   person["first" + suffix];
   >   ```
   >
   > * 在 ES6 中改善了其计算属性的缺陷
   >
   >   ```javascript
   >   var lastName = "last name";
   >   var suffix = " name";
   >   
   >   var person = {
   >   	"first name": "Nicholas",
   >   	[lastName]: "Zakas",
   >       ["first" + suffix]: "Nicholas",
   >   };
   >   
   >   console.log(person["first name"]); // "Nicholas"
   >   console.log(person[lastName]); // "Zakas"
   >   ```



## 新增方法

**ES 从 ES5 开始就有一个设计意图：避免创建新的全局函数，避免在 Object 对象的原型上
添加新方法，而是尝试寻找哪些对象应该被添加新方法。因此，对其他对象不适用的新方法
就被添加到全局的 Object 对象上。**

1. Object.is()方法

   > 严格相等运算符(===) 会认为 +0 与 -0 相等, 也会认为 NaN === NaN 会返回 false.
   >
   > 而 `Object.is()` 修复了这些特殊表现
   >
   > ```javascript
   > console.log(+0 == -0); // true
   > console.log(+0 === -0); // true
   > console.log(Object.is(+0, -0)); // false
   > 
   > console.log(NaN == NaN); // false
   > console.log(NaN === NaN); // false
   > console.log(Object.is(NaN, NaN)); // true
   > 
   > console.log(5 == 5); // true
   > console.log(5 == "5"); // true
   > console.log(5 === 5); // true
   > console.log(5 === "5"); // false
   > console.log(Object.is(5, 5)); // true
   > console.log(Object.is(5, "5")); // false
   > ```

2. Object.assign() 方法: 混入, 一个对象会从另一个对象中接收属性与方法

   由于方法内部是使用 赋值运算符(=)的, 它就无法将访问属性复制到接受者上(会调用访问器属性的 `get` 的方法)

   ```javascript
   var receiver = {};
   Object.assign(receiver,
   	{
   		type: "js",
   		name: "file.js"
   	},
       // 同属性, 后面的会覆盖前面的
   	{
   		type: "css"
   	}
   );
   console.log(receiver.type); // "css"
   console.log(receiver.name); // "file.js"
   
   // === 供应者的访问器属性就会转变成接收者的数据属性 ===
   var receiver = {},
   supplier = {
   	get name() {
   		return "file.js"
   	}
   };
   
   Object.assign(receiver, supplier);
   
   var descriptor = Object.getOwnPropertyDescriptor(receiver, "name");
   
   console.log(descriptor.value); // "file.js"
   console.log(descriptor.get); // undefined
   ```

