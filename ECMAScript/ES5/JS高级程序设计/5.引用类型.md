**在 ECMAScript 中, 引用类型是一种数据结构, 用于将数据和功能组织在一起.**

ECMAScript 提供了很多原生引用类型(例如 Object).

## 1. Object 类型

Object 是 ECMAScript 中使用最多的一个类型

1. 创建方式:

   * 使用 new 操作符后跟 Object 构造函数

   * 使用对象字面量表示法

     > 在通过对象字面量定义对象时, 实际上不会调用 Object 构造函数

2. 访问属性: 

   * 点表示法

   * 方括号表示法

     > 主要优点是可以通过变量来访问属性



## 2. Array 类型

数组是数据的有序列表

1. 特点(主要与其他语言对比):

   * ECMAScript 数组的每一项可以保存任何类型的数据
   * ECMAScript 数组的大小是可以动态调整的, 即可以随着数据的添加自动增长以容纳新增数据.

2. 创建数组

   * 使用 Array 构造函数

     > 当传递一个值时, 如果传递的是数值, 则会按照该数值创建包含给定项数的数组; 而如果传递的是其他类型的参数, 则会创建包含那个值的只有一项的数组
     >
     > ```javascript
     > var colors = new Array(3); // 创建一个包含 3 项的数组
     > var names = new Array("Greg"); // 创建一个包含 1 项, 即字符串"Greg"的数组
     > ```

   * 使用数组字面量

     > 与对象一样, 在使用数组字面量表示法时, 也不会调用 Array 构造函数

3. 读取和设置数组的值时, 要使用方括号并提供相应值的基于0 的数字索引;

4. 数组的 length 属性很有特点——**它不是只读的**. 因此, 通过设置这个属性, 可以从数组的末尾移除项或向数组中添加新项

### 2.1 检测数组

* 使用 instanceof 操作符在网页包含多个框架时, 就会出现问题
* ES5 新增了 Array.isArray() 方法

### 2.2 转换方法

`toLocaleString()`、`toString()`、`valueOf()`、`join()` 方法;

**如果数组中的某一项的值是 `null` 或 `undefined`, 那么该值的返回结果中以空字符串表示;**

* toString(): 会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串;

  > 实际上, 是会调用数组每一项的 toString() 方法

* valueOf(): 返回原数组;

* toLocalString(): 一般来讲, 结果与 toString() 方法返回结果一致. 区别在于, **会调用数组每一项的 toLocaleString() 方法**

* join(): 使用不同的分隔符来构建这个字符串

### 2.3 栈方法

**栈是一种 `LIFO`(后进先出) 的数据结构, 也就是最新添加的项最早被移除. 而栈中项的插入(叫做推入)和移除(叫做弹出), 只发生在一个位置——栈的顶部**. ECMAScript 为数组专门提供了 push() 和 pop() 方法, 以便实现类似栈的行为

* push(): 可以接收任意数量的参数, 把它们逐个添加到数组末尾, 并返回修改后数组的长度;
* pop(): 从数组末尾移除最后一项, 减少数组的 length 值, 然后返回移除的项;

### 2.4 队列方法

**队列数据结构的访问规则是 `FIFO`(先进先出). 队列在列表的末端添加项, 从列表的前端移除项.**通过 push() 和 `shift()` 方法实现类似队列的行为

* shift(): 移除数组中的第一个项并返回该项, 同时将数组长度减1;

通过 `unshift()` 和 `pop()` 可以从相反的方向的来模拟队列, **即在数组的前端添加项, 从数组末端移除项**

* unshift(): 在数组前端添加任意个项并返回新数组的长度. 

###  2.5 重排序方法

`reverse()` 和 `sort()` 方法, 返回值都是经过排序之后的数组;

* reverse(): 反转数组项的顺序;

* sort(): 对数组项进行排序;

  > 默认情况下, 会调用每个数组项的 `toString()` 转型方法, 然后比较得到的字符串, 已确定如何排序. **即使数组中的每一项都是数值, sort() 方法比较的也是字符串**

### 2.6 操作方法

ECMAScript 为操作已经包含在数组中的项提供了很多方法;

`concat()`、`slice()`、`splice()`方法, 都是返回新数组, 不会改变原数组;

* concat(): 基于当前数组中的所有项创建一个新数组;
* slice(): 基于当前数组中的一或多个项创建一个新数组, 返回起始位置和结束位置之间的项;
* splice(): 恐怕是最强大的方法, 可以用来删除、插入、替换操作;

### 2.7 位置方法

两个位置方法: `indexOf()`、`lastIndexOf()`; 都是使用全等操作符进行位置查找的;

* indexOf(): 从数组的开头(位置0)开始向后查找, 返回要查找的项在数组中的位置, 或者在没有找到的情况下返回 -1;
* lastIndexOf(): 从数组末尾开始向前查找, 返回要查找的项在数组中的位置, 或者在没有找到的情况下返回 -1;

### 2.8 迭代方法

5 个迭代方法

* every(): 对数组的每一项运行给定函数, 如果该函数对每一项都返回 true, 则返回 true;
* filter(): 对数组中的每一项运行给定函数, 返回该函数会返回 true 的项组成的数组;
* forEach(): 对数组中的每一项运行给定函数. 该方法没有返回值;
* map(): 对数组中的每一项运行给定函数, 返回每次函数调用的结果组成的数组;
* some(): 对数组中的每一项运行给定函数, 如果该函数对任一项返回 true, 则返回true;

### 2.9 归并方法

ES5 新增了两个归并方法: reduce() 和 reduceRight();

* reduce(): 从数组的第一项开始, 迭代数组的所有项, 然后构建一个最终返回的值.
* reduceRight(): 从数组的最后一项开始, 迭代数组的所有项, 然后构建一个最终返回的值.

## 3. Date 类型

要创建一个日期对象, 使用 `new` 操作符和 `Date` 构造函数即可;

`var now = new Date()`;

### 3.1 获取时间戳的方法

1. Data.now(): 返回表示调用这个方法时的日期和时间的毫秒数;

2. 使用+操作符把 Date 对象转换为字符串;

   `+new Date()`;

3. valueOf(): 返回日期的毫秒表示;

### 3.2 继承的方法

`toLocaleString()` 和 `toString()` 方法通常返回带有时区信息的日期和时间, 但因浏览器而异, 用途不大;

Date 类型的 valueOf() 方法, 则是返回日期的毫秒表示, 因此, **可以方便使用比较操作符来比较日期值**;

```javascript
var date1 = new Date(2007, 0, 1); //"January 1, 2007"
var date2 = new Date(2007, 1, 1); //"February 1, 2007"
// 因为比较操作符会默认调用 Date 类型的 valueOf() 方法强制转换类型;
alert(date1 < date2); //true
alert(date1 > date2); //false
```

### 3.3 其他方法

> 自行查阅



## 4. RegExp 类型

略



## 5. Function 类型

**函数实际上是对象. **没有函数都是 Function 类型的实例, 而且都与其他引用类型一样具有属性和方法.

**创建函数:**

1. 函数声明;

   ```javascript
   function sum (num1, num2) {
   	return num1 + num2;
   }
   ```

2. 函数表达式;

   ```javascript
   var sum = function(num1, num2){
   	return num1 + num2;
   };
   ```

3. 使用 Function 构造函数;

   > 这种语法会导致解析两次代码(第一次是解析常规 ECMAScript 代码, 第二次是解析传入构造函数中的字符串), 从而影响性能;

   ```javascript
   var sum = new Function("num1", "num2", "return num1 + num2"); // 不推荐
   ```

**注意点**: 

1. 函数是对象, 函数名是指针;
2. 使用不带圆括号的函数名是访问函数指针, 而非调用函数;

### 5.1 没有重载(深入理解)

将函数名想象为指针, 有助于理解 ECMAScript 中没有函数重载的概念;

```javascript
function addSomeNumber(num){
	return num + 100;
}
function addSomeNumber(num) {
	return num + 200;
}
// 等同于
var addSomeNumber = function (num){
	return num + 100;
};
// 在创建第二个函数时, 实际上覆盖了引用第一个函数的变量 addSomeNumber;
addSomeNumber = function (num) {
	return num + 200;
};
```

### 5.2 函数声明与函数表达式

函数声明与函数表达式一点区别: 

**函数声明会提升函数, 会将函数声明提升到顶部**

### 5.3 作为值的函数

ECMAScript 中的函数名本身就是变量, 所以函数也可以值来使用. **也就是说, 不仅可以像传递参数一样把一个函数传递给另一个函数, 而且可以将一个函数作为另一个函数的结果返回**

### 5.4 函数内部属性

**在函数内部, 在着几个特殊的对象:**

1. arguments: 主要用途是保存函数参数, **但这个对象还有一个名叫 callee 属性, 该属性是一个指针, 指向拥有这个 arguments 对象的函数**

   > 在严格模式下, 访问 arguments.callee 会导致错误;

   ```javascript
   function factorial(num){
   	if (num <=1) {
   		return 1;
   	} else {
   		return num * arguments.callee(num-1)
   	}
   }
   ```

2. this: 引用的是函数据以执行的环境对象——或者也可以说是 this 值(当在网页的全局作用域中调用函数时, this 对象引用的就是 window);

3. ES5规范的 caller 属性: 保存着调用当前函数的函数的引用, 如果是在全局作用域中调用当前函数, 它的值为 null;

   ```javascript
   function outer(){
   	inner();
   }
   function inner(){
   	alert(inner.caller); // outer() 函数的源代码
   }
   outer();
   ```

### 5.5 函数属性和方法





