## 1. 安装

### 1.1 本地安装

```bash
npm install --save-dev webpack

# 使用 webpack v4+ 版本，还需要安装 CLI
npm install --save-dev webpack-cli
```



## 2. 起步

首先创建一个目录，初始化 npm，然后在本地安装 webpack ，接着安装 webpack-cli（此工具用于在命名行中运行 webpack ）：

```bash
npm init -y # 初始化项目
npm install webpack webpack-cli --save-dev # 下载webpack webpack-cli
```



* 构建： npx webpack --config webpack.config.js

  ```bash
  # 这里使用 --config 选项知识表明，可以传递任何名称的配置文件，这对于需要拆分成多个文件的复杂配置是非常有用的。
  # 默认值就是 webpack.config.js 
  npx webpack --config webpack.config.js
  ```




## 3. 开发环境

webpack 提供几种可选方式，在代码发生变化后自动编译代码：

* webpack watch mode（webpack 观察模式）；
* webpack-dev-serve（常用）
* webpack-dev-middleware;



## 4. 模块热替换

模块热替换是 webpack 提供的最有用的功能之一。**运行在运行时更新所有类型的模块，而无需完全刷新。**



## 5. tree shaking

tree shaking 是一个术语，通常用于描述移除 JS 上下文中的未引用代码。**它依赖于 ES2015 模块语法的静态结构特性，例如 import 和 export。这个术语和概念实际上是由 ES2015 模块打包工具 rollup 普及起来的。**

**webpack 2 正式版本内置支持 ES2015 模块和未使用模块检测能力。新的 webpack4 正式版本扩展了此检测能力，通过 package.json 的 “sideEffects” 属性作为标记，向 compiler 提供提示，表明项目中的哪些文件是 “pure(纯的 ES2015 模块)" 由此可以安全地删除文件中未使用的部分。**

### 5.1 结论

我们已经知道，想要使用 *tree shaking* 必须注意以下……

- 使用 ES2015 模块语法（即 `import` 和 `export`）。
- 确保没有 compiler 将 ES2015 模块语法转换为 CommonJS 模块（这也是流行的 Babel preset 中 @babel/preset-env 的默认行为 - 更多详细信息请查看 [文档](https://babel.docschina.org/docs/en/babel-preset-env#modules)）。
- 在项目 `package.json` 文件中，添加一个 "sideEffects" 属性。
- 通过将 `mode` 选项设置为 [`production`](https://webpack.docschina.org/concepts/mode/#mode-production)，启用 minification(代码压缩) 和 tree shaking。

你可以将应用程序想象成一棵树。绿色表示实际用到的 source code(源码) 和 library(库)，是树上活的树叶。灰色表示未引用代码，是秋天树上枯萎的树叶。为了除去死去的树叶，你必须摇动这棵树，使它们落下。



## 6. 生产环境

development(开发环境) 和 production(生产环境) 这两个环境下的构建目标存在着巨大差异。

**开发环境中，我们需要localhost server:**

* 强大的 source map 
* live reloading(实时重新加载) 或 hot module replacement(热模块替换)能力的 

**生产环境，我们关注点：**

* 压缩 bundle
* 更轻量的 source map
* 资源优化等

> **通过这些优化方式改善加载时间。**



### 6.1 压缩(minification)

**设置 production mode 配置后，webpack4+ 会默认压缩代码。**

**注意：**生产环境下默认使用 TerserPlugin，并且也是代码压缩方面比较好的选择，但是还有一些其他可选择项。以下有几个同样很受欢迎的插件：

* BabelMinifyWebpackPlugin
* ClosureCompilerPlugin



### 6.2 源码映射(source mapping)

我们鼓励你在生产环境中启用 source map，因为它们对 debug(调试源码) 和运行 benchmark tests(基准测试) 很有帮助。虽然有着如此强大的功能，然而还是应该针对生产环境用途，选择一个可以快速构建的推荐配置（更多选项请查看 [`devtool`](https://webpack.docschina.org/configuration/devtool)）



## 7. 代码分离

代码分离是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。

常用的代码分离方法有三种：

* 入口起点：使用 entry 配置手动地分离代码；
* 防止重复：使用 splitChunksPlugin 去重和分离 chunk；
* 动态导入：通过模块中的内联函数调用来分离代码；



### 7.1 入口起点

这种方式手动配置较多，并有一些隐患；

* 如果入口 chunk 之间包含一些重复的模块，那些重复模块都会被引入到各个 bundle 中。
* 这种方式不够灵活，并且不能动态地将核心应用程序逻辑中的代码拆分出来。



### 7.2 防止重复

**SplitChunksPlugin 插件可以将公共的依赖模块提取到已有的 entry chunk 中，或者提取到一个新生成的 chunk。**

以下是由社区提供，一些对于代码分离很有帮助的 plugin 和 loader：

- [`mini-css-extract-plugin`](https://webpack.docschina.org/plugins/mini-css-extract-plugin)：用于将 CSS 从主应用程序中分离。
- [`bundle-loader`](https://webpack.docschina.org/loaders/bundle-loader)：用于分离代码和延迟加载生成的 bundle。
- [`promise-loader`](https://github.com/gaearon/promise-loader)：类似于 `bundle-loader` ，但是使用了 promise API。



### 7.3 动态导入

动态代码拆分时，webpack 提供了两个类似的技术。

* 推荐使用，使用符合 ECMAScript 提案的 import() 语法来实现动态导入。
* webpack 的遗留功能，使用 webpack 特定的 require.ensure